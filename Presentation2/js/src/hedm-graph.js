/*
 *hedm-graph.js builds the er-graph.
*/

var edges;
var nodes; 

var g;
var render;
var inner;
var zoom;
var initialScale = 1;
var name;

// format of the tool tip
function styleTooltip(name, description) {
  return "<p class='name'>" + name + "</p><p class='description'>" + description + "</p>";
}

/*
 * setGraph
 * references var g declared at the begining of the file
 * add elements from var nodes, edges generated by a schema crawl
 */
function setGraph() {
  // set nodes
  nodes.forEach( function(node) {
    // set corner properties
    node.rx = 0;
    node.ry = 0;
    node.style = "fill: #fff; stroke: #d2d2d2";
    node.labelStyle = "fill: #393939;";
    // create node
    g.setNode(node.name, node);
  });
  // set edges
  edges.forEach( function(edge) {
    // if does not have specified arrow
    if(typeof edge.arrowhead === 'undefined')
      g.setEdge(edge.start, edge.end);
    else
      g.setEdge(edge.start, edge.end, { arrowhead: edge.arrowhead });
  });
}

function trimGraph() {
  g.nodes().forEach(function(node) {
    if(node != name) {
      try {
	if(g.neighbors(name).indexOf(node) < 0) {
	  g.removeNode(node);
	}
      } catch(err) { return; }
	
    }
  });
}

/* 
 * clearGraph
 * references var g declared at the begining of the file
 * removes all nodes from g
 */
function clearGraph(){
  g.nodes().forEach( function(node) {
    g.removeNode(node);
  })
}
/* set display and function prefs of graph */
function setDisplayPref() {
  var node = inner.selectAll("g.node")
  node.attr("title", function(v) {
    return styleTooltip(parseName(v), g.node(v).description); // return structure form 
  });
  node.each(function(v) { // set display properties using tipsy.js
    $(this).tipsy( {
      gravity: "e",
      opacity: 1,
      html: true
    });
  });
  node.on('click', function(v) {
    var href = g.node(v).href;
    location.href = href;
  });
  node.on('mouseover', function(v) {
    $(this).children('rect').css({fill: "#e8f5f4"});
  });
  node.on('mouseout', function(v) {
      $(this).children('rect').css({fill: "#fff"});
  });
  node.each(function(v) {
    $(this).children().children().children().children().html(parseName(v));
  });
  var loc = window.location.pathname;
  var dir = loc.substring(0, loc.lastIndexOf('/'));
  dir = dir.substring(dir.lastIndexOf('/') + 1);
  if(dir === 'designations') {
    inner.attr('transform', 'translate(60)');
    svg.attr('viewBox', '0 0 ' + (g.graph().width + 60) + ' ' + g.graph().height);
  } else if(dir === 'donations') {
    inner.attr('transform', 'translate(60)');
    svg.attr('viewBox', '0 0 ' + (g.graph().width + 80) + ' ' + g.graph().height);
  } else {
    svg.attr('viewBox', '0 0 ' + g.graph().width + ' ' + g.graph().height);
  }
  svg.attr('height', g.graph().height+5);
  svg.attr('width', Math.min(g.graph().width+5, $('#content').width()) - 10);

}
/* create custom arrows */
function customArrows() {
  /*
   * hollowDiamond
   * create a new arrowhead with various properties
   * refer to dagre-d3 repo for more information 
   */
  render.arrows().hollowDiamond = function normal(parent, id, edge, type) {
    var marker = parent.append("marker")
	.attr("id", id)
	.attr("viewBox", "0 0 10 10")
	.attr("refX", 9)
	.attr("refY", 5)
	.attr("markerUnits", "strokeWidth")
	.attr("markerWidth", 8)
	.attr("markerHeight", 6)
	.attr("orient", "auto");
    var path = marker.append("path")
	.attr("d", "M 0 5 L 5 0 L 9 5 L 5 10 z")
	.style("stroke-width", 1)
	.style("stroke-dasharray", "1,0")
	.style("fill", "#fff")
	.style("stroke", "#333");
    dagreD3.util.applyStyle(path, edge[type + "Style"]);
  };
}

// format entity name whit caps and spaces
function parseName(name) {
  var name = name.replace(/-/g, ' ');
  name = name.substring(0, 1).toUpperCase() + name.substring(1);
  for(var i=0; i<name.length-1; i++){
    if(name.charAt(i)==' '){
      name = name.substring(0, i) + name.substring(i, i+2).toUpperCase() + name.substring(i+2);
    }
  }
  return name;
}


$(document).ready(function() {
  var version = $("meta[name='version']").attr('content');
  version = "/" + version;
  $.get(version + "/js/src/nodes.json", function(data) {
    nodes = data;
  })
    .done(function() {
      $.get(version + "/js/src/edges.json", function(data) {
	edges = data;
      })
	.done(function() {
	  var loc = window.location.pathname;
	  var fulldir = loc.substring(0, loc.lastIndexOf('/'));
	  name = fulldir.substring(fulldir.lastIndexOf('/')+1);
	  if( name == '')
	    return;
	  // create a new dagre-d3 graph object
	  g = new dagreD3.graphlib.Graph()
	    .setGraph( {} ) // create an empty graph
	    .setDefaultEdgeLabel( function() { return {}; }); // set default edge lable to blank
	  setGraph(); // set graph with nodes and edges
	  trimGraph(); // remove nodes edges that are not neighbors
	  render = new dagreD3.render(); // create a new dagred3 render object
	  svg = d3.select("svg"); 
	  inner = svg.append("g");
	  customArrows();
	  render(inner, g); // render graph
	  setDisplayPref();
	});
    });
});

